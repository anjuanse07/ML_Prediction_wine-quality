# ML_Prediction_wine-quality

## Domain Proyek

Saya mengambil domain proyek yang termasuk kedalam ekonomi dan bisnis. proyek yang saya angkat berjudul prediksi kualitas _wine_, yang tujuan-nya adalah meningkatkan kualitas produksi _wine_ di Indonesia. Yang melatarbelakangi saya untuk mengambil hal itu dikarenakan potensi Indonesia dalam komoditas anggur masih dapat dikembangkan lebih jauh, perkebunan anggur di Indonesia dari tahun 2012 sampai saat ini terus meningkat namun hanya untuk beberapa daerah saja. Salah satu daerah penghasil minuman anggur dengan skala internasional di Indonesia adalah Bali, yang memiliki beberapa produsen anggur ternama yang sudah berdiri sejak lama. Dari hasil penelitian yang dilakukan di Bali, ditemukan persepsi wisatawan yang mengkonsumsi produk hasil perusahaan _wine_ nya Bali, menunjukkan bahwa konsumen merasakan kualitas produk yang baik dan menunjukan ketertarikan mereka untuk melakukan _wine tourism_. Berdasarkan hal tersebut potensi Indonesia untuk mengembangkan produksi _wine_ masih bisa ditingkatkan dan dikembangkan lebih jauh agar menjadi daya tarik dengan potensi maksimal yang dapat meningkatkan perekonomian, khususnya bagi beberapa daerah yang memiliki komoditas lahan anggur di Indonesia. Minuman anggur atau _wine_ yang dihasilkan biasanya merupakan campuran antara anggur lokal dengan anggur impor, sehingga menghasilkan cita rasa yang nikmat dengan harga yang cukup terjangkau dan tidak kalah dengan produk impor. Hal tersebut dapat menjadi tolak ukur dalam pengembangan minuman anggur lokal lebih jauh, untuk dimaksimalkan potensi kualitasnya. 

**Rubrik/Kriteria Tambahan (Opsional)**: 

- Mengapa dan bagaimana masalah tersebut harus diselesaikan : Potensi untuk meningkatkan kualitas minuman anggur di indonesia masih sangat tinggi namun sayangnya tidak semua daerah penghasil anggur memanfaatkan hal tersebut dengan baik. hal ini dapat dilihat dari perkembangan komoditas anggur di Indonesia yang terpusat hanya pada daerah Bali saja. Sedangkan banyak daerah penghasil anggur lain di Indonesia yang memiliki potensi sama baiknya untuk menghasilkan minuman anggur berkualitas yang dapat bersaing tidak hanya dengan produksi Bali namun juga secara internasional. Hal tersebut bisa diatasi apabila kualitas _wine_ di Indonesia ditingkatkan dan ditinjau lebih jauh, maka Indonesia akan sekali lagi membuka peluang dalam komoditas bisnis minuman anggur, yang tidak kalah saing dengan negara lain. ada beberapa cara untuk meningkatkan kualitas _wine_ di Indonesia, mulai dari proses pertumbuhan dan perkembangan perkebunan anggur, masalah perawatan, masalah lahan, dan lain sebagainya. Namun untuk kali ini yang akan ditawarkan adalah dengan melihat hasil prediksi kualitas anggur dari negara lain sehingga dapat menjadi target kualitas bagi produk lokal untuk dapat bersaing secara sehat. Dari hasil prediksi tentunya terdapat beberapa atribut yang menjadi tolak ukur pembuatan anggur dengan kualitas yang baik. Diharapkan dari atribut tersebut, akan menjadi penopang dan target produsen lokal dalam menciptakan anggur dengan kualitas yang sama baiknya atau bahkan lebih baik.


- Hasil Riset terkait : 
[1] Putu Gita Dewi Ayu _et al_, _STRATEGI PENGEMBANGAN WINE TOURISM
DI KABUPATEN BULELENG-BALI_ , Jurnal IPTA p-ISSN : 2338-8633
Vol. 6 No. 1, 2018 , e-ISSN : 2548-7930.
[2] Admin. 2019, Oktober 18. _Wine Produksi Bali Ini Sudah Diekspor ke Singapura dan Vietnam_.artikel. [Tautan Artikel](https://kumparan.com/kumparanbisnis/wine-produksi-bali-ini-sudah-diekspor-ke-singapura-dan-vietnam-1s52LszGhev/full)
[3] Emi Budiyati _et al_. 2021, Maret 25. _Geliat Perkembangan Tanaman Anggur di Pulau Dewata Bali_. artikel. [Tautan Artikel]( http://balitjestro.litbang.pertanian.go.id/geliat-perkembangan-tanaman-anggur-di-pulau-dewata-bali/)

## Business Understanding

Jika kita ada diposisi sebagai pemilik perusahaan produksi yang bergerak di bidang produksi _wine_. Model bisnis yang diterapkan tentunya kita sebagai produsen, yang harus menjual produk atau mendistribusikan produk kita untuk sampai ditangan konsumen. Namun tentunya produk yang dihasilkan akan diterima lebih baik oleh pihak konsumen, apabila produk kita memiliki cita rasa yang menarik dan nikmat saat dikonsumsi. Disatu sisi pengalaman perusahaan kita untuk membuat _wine_ dengan kualitas tinggi masih kurang, sehingga tidak mampu bersaing dengan _wine_ hasil produksi perusahaan lain. Maka dari itu, diharuskan untuk melakukan riset, mengubah resep, dan terus melakukan percobaan agar _wine_ yang dihasilkan memiliki kualitas yang baik. Untuk membantu pengupayaan hal tersebut, perlu diterapkannya otomasi pada sistem prediksi kualitas _wine_ dengan teknik predictive modelling. Agar proses pembuatan _wine_ dapat dilakukan dengan lebih terarah dan dapat diketahui karakteristik apa saja yang membuat sebuah _wine_ memiliki kualitas terbaik.

dan Tentu saja semua bisnis mengejar profit. Oleh karena itu, penting bagi perusahaan untuk mengetahui dan dapat memprediksi kualitas _wine_ yang dijual di pasar. Prediksi akan digunakan untuk mencari kombinasi karakteristik yang pas untuk produksi _wine_. Demi tujuan memiliki kualitas terbaik yang kemudian dapat dijual dipasar agar mendapatkan profit sebesar mungkin.

### Problem Statements

Berdasarkan kondisi yang telah dijabarkan pada poin sebelumnya, saya akan mengembangkan sebuah sistem prediksi kualitas _wine_ untuk menjawab permasalahan berikut.
- Dari serangkaian atribut yang dimiliki oleh _wine_, atribut apa yang paling berpengaruh terhadap kualitas _wine_?
- Seberapa tinggi kualitas _wine_ yang dihasilkan dengan beberapa karakteristik yang dimiliki oleh suatu produk?  

### Goals
Untuk  menjawab pertanyaan tersebut, saya akan membuat predictive modelling (model regresi) dengan tujuan atau goals sebagai berikut:
- Mengetahui atribut yang paling berkorelasi dengan kualitas _wine_.
- Membuat model machine learning yang dapat memprediksi kualitas _wine_ dengan akurasi tinggi berdasarkan atribut yang ada.

### Solution statements
- Prediksi kualitas termasuk kedalam salah satu variabel yang bernilai kontinu. Dalam predictive analytics, saat membuat prediksi variabel kontinu sesuai dengan teori yang sudah dijelaskan adalah kita mengatasi permasalahan atau problem regresi. Oleh karena itu, pada proyek ini ditujukan membangun model regresi dengan kualitas _wine_ sebagai target. Untuk mencapai nilai akurasi yang setinggi-tingginya diperlukan tuning hyperparameter yang digunakan dalam pembuatan model machine learning. dalam implementasinya pada proyek ini akan membandingkan hasil 4 model, yaitu model dengan KNN, Random Forest, Boosting, dan Sekuensial. Agar mencapai nilai akurasi maksimal, ke empat model tersebut akan di eksuksi untuk kemudian dibandingkan setelah pengaturan hyperparameter disesuaikan agar mendapat hasil terbaik. Dari ke- empat model ini, akan dipilih satu model yang memiliki nilai kesalahan prediksi terkecil. Dengan kata lain, akan dibuat model yang akurat dengan tingkat loss yang kecil.
-  Metrik yang digunakan dalam mengevaluasi model dalam memprediksi kualitas atau model regresi kali ini adalah Mean Squared Error (MSE) (untuk KNN, Random Forest, Boosting). Secara umum, metrik ini mengukur seberapa jauh hasil prediksi dengan nilai yang sebenarnya. sedangkan untuk model sekuensial menggunakan metrik mae (Mean Absolute Error). 


## Data Understanding
Data yang Saya gunakan pada proyek kali ini adalah _Wine Quality_ dataset yang saya temui dan diunduh dari kaggle. Setelah beberapa kali pencarian, saya menemukan dataset yang terbilang cukup baik ketika di download dan dicek. Dataset ini memiliki 1143 baris dengan total 13 kolom karakteristik. Semua yang ada didataset bertipe numerikal dan tidak ada data kategorikal. Beberapa contoh karakteristiknya adalah tingkat keasaman _wine_, pH, kandungan asam sitrat, kandungan klorida, kandungan sulfat, dan sebagainya. Berikut adalah tautan untuk mendownload dataset yang digunakan - [Kaggle](https://www.kaggle.com/datasets/yasserh/wine-quality-dataset).

### Variabel-variabel pada Wine Quality Dataset adalah sebagai berikut:
Variabel didapatkan berdasarkan uji fisikokimia
- fixed acidity : keasaman tetap pada _wine_.
- volatile acidity : ukuran dari asam lemak dengan berat molekul rendah (atau dapat disuling dengan uap) dalam anggur dan umumnya dianggap sebagai bau cuka.
- citric acid : asam kristal yang rasanya tajam yang ada pada buah dengan rasa masam.
- residual sugar : berasal dari gula anggur alami yang tersisa dalam anggur setelah fermentasi alkohol selesai.
- chlorides : klorida - disebabkan oleh ion yang diekstraksi selama fermentasi.
- free sulfur dioxide : sulfid yang tersedia untuk bereaksi dan dengan demikian menunjukkan sifat kuman dan antioksidan.
- total sulfur dioxide : bagian SO2 yang bebas dalam anggur ditambah bagian yang terikat dengan bahan kimia lain dalam anggur seperti aldehida, pigmen, atau gula.
- density : massa per satuan volume anggur atau harus pada 20°C.
- pH : tingkat pH akan berdampak besar pada rasa dan aroma wine. Secara khusus, tingkat pH yang lebih rendah dikaitkan dengan rasa asam dan renyah.
- sulphates : kandungan bahan pengawet yang menghambat kegiatan dan pertumbuhan dari bakteri maupun mikrooganisme yang terdapat dalam bahan dasar.
- alcohol : jumlah etanol dalam volume cairan tertentu, pada kasus ini _wine_.
- quality (score between 0 and 10) : Kualitas _wine_ dengan tingkat dari 0 sampai dengan 10.
- ID : penamaan (label) pada tiap baris wine di dataset.


- Setelah melakukan data loading pada dataset dan mengetahui jumlah baris dan kolom yang terdapat pada dataset, saya masuk ke tahap EDA atau Exploratory Data Analysis. Hal tersebut dilakukan untuk menganalisis karakteristik, menemukan pola, anomali, dan memeriksa asumsi pada data. pada bagian ini adalah deskripsi variabel yang didapat dari informasi yang disediakan pada kaggle. kemudian saya melakukan deklarasi data.info() untuk mencari tahu tipe data yang ada pada dataset, diketahui bahwa ada 11 data tipe float64 dan 2 data tipe int64, semuanya adalah data numerikal ,tidak ada kategorikal. Selanjutnya adalah menggunakan fungsi .drop() untuk membuang kolom yang tidak dibutuhkan dari dataset, pada proyek kali ini yang di drop adalah kolom ID, karena dari hasil pengamatan ,kolom ini tidak akan memberikan pengaruh signifikan. kemudian untuk mengecek apakah sudah terhapus bisa dengan mendeklarasikan kembali variabel "data".
- Kemudian memanggil fungsi describe() yang memberikan informasi statistik pada masing-masing kolom, dimana Count adalah jumlah sampel pada data. Mean adalah nilai rata-rata. Std adalah standar deviasi. Min yaitu nilai minimum setiap kolom. 25% adalah kuartil pertama. Kuartil adalah nilai yang menandai batas interval dalam empat bagian sebaran yang sama. 50% adalah kuartil kedua, atau biasa juga disebut median (nilai tengah). 75% adalah kuartil ketiga. Max adalah nilai maksimum.
- Masih dalam tahap EDA - missing value, untuk memastikan kembali tidak ada data kosong maka fungsi .isna().sum() digunakan untuk mencari jumlah data yang tidak memiliki nilai, atau data kosong (NULL/NaN).
- Selanjutnya masuk ketahap untuk menangani outliers sebagai tahap bagian dari EDA. untuk melihat secara langsung outliers yang ada pada tiap data bisa dengan teknik visualisasi data (boxplot) menggunakan fungsi sns.boxplot(). boxplot menunjukkan ukuran lokasi dan penyebaran, serta memberikan informasi tentang simetri dan outliers. Kemudian, menangani outliers dengan teknik IQR method atau Inter Quartile Range. metode IQR mengidentifikasi outlier yang berada 1,5 kali di besar IQR di luar Q1 dan Q3 (kuartil 1 dan kuartil 3). Nilai apa pun yang berada di luar batas ini dianggap sebagai outlier. hasil dari penanganan outliers dapat dilihat dengan menggunakan kode data.shape() yang menghitung ulang jumlah baris x kolom yang sudah bersih. (dalam proyek ini dataset menjadi 834 baris x 12 kolom).
- Selanjutnya, dilakukan proses analisis data dengan menggunakan teknik Univariate EDA. yang harus dilakukan adalah membagi dataset menjadi numerikal dan kategorikal, namun dikarenakan semua tipe data yang digunakan tidak ada yang bertipe kategorikal, maka hanya numerikal yang di deklarasikan. Untuk melihat fitur numerik, dideklarasikan fungsi histogram untuk melihat histogram masing-masing fiturnya untuk dianalisa. dari hasil histogram dapat diketahui bahwa hampir tiga per empat kualitas _wine_ berada pada nilai 5 dan 6 ,sedangkan yang tertinggi adalah 7.
- Masih dalam tahapan EDA, setelah melalui univariate EDA, sekarang adalah Multivariate EDA yangmenunjukkan hubungan antara dua atau lebih variabel pada data. Multivariate EDA yang menunjukkan hubungan antara dua variabel biasa disebut sebagai bivariate EDA. Untuk mengamati hubungan antara fitur numerik,akan digunakan fungsi pairplot(). Fungsi pairplot dari library seaborn menunjukkan relasi pasangan dalam dataset.
- Tahap selanjutnya dalam EDA adalah dengan menggunakan fungsi .corr() untuk mencari korelasi sebaran data pada grafik pairplot yang sudah dideklrasikan, Korelasi pada fitur tampak dari adanya pola pada sebaran data. Arah korelasi antara dua variabel bisa bernilai positif (nilai kedua variabel cenderung meningkat bersama-sama) maupun negatif (nilai salah satu variabel cenderung meningkat ketika nilai variabel lainnya menurun). dengan melihat nilai yang tertera pada correlation matriks yang sudah dibuat, dapat dianalisis dan diambil keputusan bahwa ada beberapa variabel yang tidak memiliki korelasi yang cukup kuat satu sama lain. data berada pada rentang -1 sampai dengan 1, semakin tinggi korelasinya warna cell pada matriks akan semakin menuju warna merah dan angka korelasinya akan tinggi, kebalikannya jika semakin rendah korelasinya maka akan semakin biru. dari data diketahui terdapat beberapa matriks yang korelasinya buruk, sehingga diputuskan untuk dibuang dengan fungsi .drop(). Lalu dilakukan pengecekan kembali atas matriks korelasi yang sudah di minimalisasi dari nilai korelasi yang buruk.

## Data Preparation
Masuk ke tahap persiapan data. karena tidak ada data kategorikal maka tidak diperlukan penggunaaan fungsi encoding, serta tidak ada Reduksi Dimensi dengan PCA dikarenakan data dimensi tidak ada pada dataset _wine quality_. Pada bagian preparasi data, yang saya lakukan adalah sebagai berikut: 
- Melakukan pembagian dataset menjadi data training dan data test dengan menggunakan fungsi train_test_split 
- Standarisasi data menggunakan standardscaler(). 

Proses pertama yang dilakukan dalam tahap persiapan data adalah memisah data untuk training dan test dengan fungsi train_test_split. salah satu alasan mengapa data harus displit adalah untuk menghindari terjadinya _overfitting_. Data training nantinya akan digunakan untuk melatih algoritma dalam mencari model yang sesuai, sedangkan data testakan dipakai untuk menguji dan mengetahui performa model yang didapatkan pada tahapan test/predict. rasio perbandingan datatraining dan datatest adalah 1:9 , rasio ini diambil dikarenakan jumlah total dataset terbilang cukup sedikit sehingga diperlukan data train lebih banyak daripada data test , nilai variabel X berisi semua atribut yang dijadikan input (data numerikal), sedangkan variabel y menjadi target dari x yaitu kualitas. Parameter randomstate juga dideklarasikan,parameter ini berfungsi untuk mengontrol random number generator yang digunakan. Pada kasus ini, saya menerapkan random_state = 123. sehingga berapa pun nilai integer yang ditentukan ,selama itu bilangan integer, ia akan memberikan hasil yang sama setiap kali dilakukan pemanggilan fungsi. 

Selanjutnya adalah melakukan standarisasi. algoritma machine learning memiliki performa lebih baik dan konvergen lebih cepat ketika dimodelkan pada data dengan skala relatif sama atau mendekati distribusi normal. Proses scaling dan standarisasi membantu untuk menyeragamkan nilai-nilai data yang pada penginputan formatnya tidak konsisten menggunakan suatu standar tertentu, hingga seluruh data memiliki skala yang sama besar. Antara lain dikarenakan besar nilai antara data yang satu dengan data yang lain berjarak cukup besar sehingga perlu di standarisasi agar nilai tersebut tidak memiliki perbedaan skala yang besar. fungsi standardscaler() akan menormalkan atau menstandarisasikan tiap nilai atribut variabel yang dideklarasikan agar memiliki mean = 0 dan standar deviasi = 1 antara satu sama lain. scaling hanya dilakukan pada data x_train saja untuk mengurangi resiko kebocoran data sebelum pelatihan model.

## Modeling
Masuk kedalam tahap Pengembangan model, dimana pada tahap ini saya menggunakan 3 buah model seperti yang dicontohkan dalam submodul study case pertama : predictive Analysis, namun terlebih dahulu menyiapkan data frame untuk analisis ketiga model tersebut untuk pada akhirnya sebagai tempat hasil pelatihan model tersebut disimpan. metriks yang digunakan adalah mean squarred error (MSE).
 - Algoritma KNN 
   - Selanjutnya, untuk melatih data dengan KNN, bisa dengan menggunakan fungsi KNeighborsRegressor dari library sklearn. Algoritma KNN menggunakan ‘kesamaan fitur’ untuk memprediksi nilai dari setiap data yang baru. Dengan kata lain, setiap data baru diberi nilai berdasarkan seberapa mirip titik tersebut dalam set pelatihan. Pemilihan nilai k sangat berpengaruh terhadap performa model. Jika kita memilih k yang terlalu rendah, maka model kan overfit dan hasil prediksinya memiliki varians tinggi. Jika kita memilih k terlalu tinggi, maka model yang dihasilkan akan underfit dan prediksinya memiliki bias yang tinggi. Parameter yang digunakan pada metode ini adalah parameter K. pada proyek ini setelah beberapa kali percobaan diputuskan untuk menggunakan k = 10 tetangga dan metric Euclidean untuk mengukur jarak antara titik. hasil model disimpan pada lokasi yang telah dideklarasikan pada program.
- Algoritma Random Forest
    - Selanjutnya, dengan model kedua membuat variabel Random Forest dan memanggil RandomForestRegressor dengan beberapa nilai parameter. Model decision tree masing-masing memiliki hyperparameter yang berbeda dan dilatih pada beberapa bagian (subset) data yang berbeda juga. Random forest pada dasarnya adalah versi bagging dari algoritma decision tree. Pada kasus regresi, prediksi akhir adalah rata-rata prediksi seluruh pohon dalam model ensemble. Sedangkan parameter yang digunakan adalah, n_estimator: jumlah trees (pohon) di forest. max_depth: kedalaman atau panjang pohon. random_state: digunakan untuk mengontrol random number generator yang digunakan. n_jobs: jumlah job (pekerjaan) yang digunakan secara paralel. n_jobs=-1 artinya semua proses berjalan secara paralel. 
- Algoritma Boosting Regressor
    - Pada model ini, digunakan model adaboostregressor, yang dimana jika semua kasus dalam data latih memiliki weight atau bobot yang sama. maka Pada model ini di setiap tahapan, model akan memeriksa apakah observasi yang dilakukan sudah benar, Bobot yang lebih tinggi kemudian diberikan pada model yang salah sehingga mereka akan dimasukkan ke dalam tahapan selanjutnya. Parameter-parameter yang digunakan pada potongan kode di atas adalah learning_rate: bobot yang diterapkan pada setiap regressor di masing-masing proses iterasi boosting dan randomstate: digunakan untuk mengontrol random number generator yang digunakan.
 - Algoritma Model Sekuensial
   - Model ini merupakan dasaran dari salah satu pemodelan yang digunakan untuk Neural Network atau jaringan syaraf buatan, model sekuensial ini merupakan tumpukan polos lapisan dimana masing-masing lapisan memiliki tepat satu tensor input dan satu output tensor, seperti model jaringan syaraf neuron. dengan menggunakan fungsi keras.layers. nantinya setiap layer pada jaringan saraf tiruan akan terhubung secara sekuensial. Parameter units dari fungsi keras.layers.Dense() adalah jumlah perseptron yang dimiliki oleh layer tersebut. Khusu untuk layer pertama dari model tersebut haruslah memiliki parameter inputshape agar model bisa mengenali bentuk input yang akan diprosesnya. Sedangkan Parameter inputshape menunjukkan bentuk dari setiap elemen input yang akan diterima oleh model. untuk keras.layers.LSTM merupakan singkatan dari Long Short-Term Memory yaitu, salah satu layer yang menggunakan deep learning untuk memecahkan masalah yang  kompleks. Sedangkan untuk normalization() digunakan karena berurusan dengan banyak label. Label-label ini bisa dalam bentuk kata-kata, angka, atau sesuatu yang lain. Fungsi ini akan menormalisasi label label tersebut. Fungsi selanjutnya adalah .dropout() untuk menghindari overfit dimana beberapa neuron akan secara acak di drop atau tidak dijalankan. Setelah model dibuat atau dibangun, untuk melihat arsitektur layernya bisa dengan menggunakan summary(). Hal yang dilakukan selanjutnya adalah menentukan optimizer dan loss dari model agar model yang dibangun bisa belajar. Untuk menentukan optimizer dan loss digunakan fungsi compile. Untuk masalah regresi, digunakan optimizer stochastic gradient descent (SGD)), dan mean absolute error sebagai metriks evualuasi kualitas. 

- Kelebihan Algoritma K-NN :
    1. Algoritma K-NN kuat dalam mentraining data yang noisy.
    2. Algoritma K-NN sangat efektif jika datanya besar.
    3. Mudah diimplementasikan.
- Kekurangan Algoritma K-NN :
    1. Algoritma K-NN perlu menentukan nilai parameter K.
    2. Sensitif pada data pencilan.
    3. Rentan pada variabel yang non-informatif.
- Kelebihan Algoritma Random Forest
    1. Kuat terhadap data outlier.
    2. Bekerja dengan baik dengan data non-linear.
    3. Risiko overfitting lebih rendah.
    4. Berjalan secara efisien pada kumpulan data yang besar.
    5. Akurasi yang lebih baik daripada algoritma klasifikasi lainnya.
- Kekurangan Algoritma Random Forest
    1. Random Forest cenderung bias saat berhadapan dengan variabel kategorikal.
    2. Waktu komputasi pada dataset berskala besar relatif lambat.
    3. Tidak cocok untuk metode linier dengan banyak fitur sparse.
- Kelebihan Algoritma Boosting
    1. Memori. Model yang ditraining secara sequensial membutuhkan memori yang lebih sedikit.
    2. Spesialisasi pada weak model.
    3. Algoritme boosting memprioritaskan fitur yang meningkatkan akurasi prediktif selama pelatihan. 
- Kekurangan Algoritma Boosting
    1. Teknik boosting cukup sensitif terhadap noise dan outlier, yaitu overfitting.
    2. Akan sulit menggunakan boosting untuk implementasi waktu nyata karena algoritmenya lebih kompleks dibandingkan proses lainnya.
- Kelebihan Algoritma Sekuensial
    1. Model JST yang paling sederhana.
    2. Mudah untuk dilakukan kalibrasi atau penyesuaian layers.
- Kekurangan Algoritma Sekuensial
    1. Sentivitas Hyperparameter yang harus ditentukan untuk disesuaikan dengan data yang digunakan.
    2. Diperlukan pengetahuan tentang keseluruhan fungsi sekuensial dan penyesuaian parameter tuning berulang-ulang untuk mendapatkan hasil yang optimal.

Model dibuat dan disusun dengan deklarasi variabel ,fungsi model algoritma,serta hyperparameter yang digunakan. kemudian model dilatih dengan model.fit() terhadap vairabel x_train dan y_train. Algoritma yang pada akhirnya dipilih adalah algoritma Boosting dikarenakan memiliki nilai metriks error dan hasil evaluasi yang paling kecil dibandingkan dengan model yang lainnya.


## Evaluation
Sebelum menghitung nilai MSE dalam model, dilakukan proses scaling fitur numerik pada data uji terlebih dahulu. Proses scaling pada data latih di penjelasan sebelumnya adalah untuk menghindari kebocoran data. Sekarang, setelah model selesai dilatih dengan 4 algoritma, yaitu KNN, Random Forest, Adaboost dan Sekuensial, perlu dilakukan proses scaling terhadap data uji. Hal ini harus dilakukan agar skala antara data latih dan data uji sama dan kita bisa melakukan evaluasi. Selanjutnya, evaluasi ke empat model tersebut dengan menggunakan metrik MSE. Untuk Model KNN, Boosting, dan Random Forest saat menghitung nilai Mean Squared Error pada data train dan test, nilainya dibagi dengan nilai 1e3. Hal ini bertujuan agar nilai mse berada dalam skala yang tidak terlalu besar. Kemudian agar data dapat lebih mudah dilihat, digunakan fungsi figure dan plt.plot() untuk menampilkan data grafik dengan format bar. Dari hasil analisa plot dapat dilihat bahwa model Boosting memberikan nilai error dan memiliki hasil evaluasi yang paling kecil dibandingkan yang lainnya. sedangkan untuk model lain nya tidak terlalu memenuhi kriteria yang diperlukan. Sedangkan untuk model sekuensial nilai menggunakan mae (mean absolute error) yang nilai standarnya didapat dari nilai minimal mae dari nilai median target "kualitas". nilai mae optimal diambil dibawah 10% nilai median tersebut. Kemudian nilai mae dijadikan sebagai metriks evaluasi pada model sekuensial.


Untuk menguji hasil prediksi model yang telah dibuat, bisa dengan melakukan prediksi menggunakan beberapa data dari data test. dengan menggunakan code model.predict() untuk mengambil memori model yang telah disimpan sebelumnya dan memprediksikan hasil data latih dari model.fit() terhadap nilai X_test dan y_test. menggunakan fungsi for untuk memanggil kembali 10 data pertama untuk menguji hasil prediksi. dengan mendeklarasikan fungsi pd.DataFrame() , outputnya akan menghasilkan hasil prediksi ketiga model yang sudah dibuat dengan data Y_test sebagai pembanding.

Mean Squarred Error : MSE mengukur kesalahan dengan menggunakan kuadrat rata-rata dari hasil prediksi model yang dihasilkan. matriks ini akan menghitung selisih kuadrat antara prediksi dan target kemudian mencari nilai rata-rata dari nilai tersebut. Semakin tinggi sebuah nilai, maka modelnya juga akan semakin tidak bagus. Nilai MSE tidak pernah negatif, karena kembali lagi metriks MSE menguadratkan kesalahan prediksi individu sebelum menjumlahkannya, tetapi akan menjadi nol untuk model yang sempurna. Namun perlu diketahui juga bahwa metriks evaluasi MSE memiliki sedikit kerugian, seperto contohnya adalah ketika ada suatu data prediksi yang sangat buruk, MSE akan mengkuadratkan data tersebut dan membuat kesalahan lebih buruk dan itu akan membuat metrik cenderung melebih-lebihkan keburukan model.

Mean Absolute Error : Dalam metriks MAE kesalahan dihitung sebagai rata-rata perbedaan absolut antara nilai target dan prediksi. metriks MAE bernilai linier sehingga semua perbedaan individu data diberi bobot yang sama rata-rata. Namun sebagai kekurangan , biasanya mmetriks MAE kurang sensitif terhadap outliers yang menjadi salah satu alasan kenapa harus ada penetapan outliers pada dataset yang digunakan. metriks MAE akan menunjukkan nilai kesalahan rata-rata yang error dari nilai sebenarnya dengan nilai prediksi atau mengukur seberapa dekat prediksi dengan hasil aktual, sehingga apabila memiliki nilai skor mae yang lebih rendah maka akan menjadi lebih baik.
